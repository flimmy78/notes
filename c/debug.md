实用的内存和内核工具

用户空间工具：
  内存工具：MEMWATCH 和 YAMD
  strace
  GNU 调试器（gdb）
  魔术键控顺序

内核工具：
  内核源代码级调试器（kgdb）
  内建内核调试器（kdb）
  Oops

MEMWATCH 
  提供结果日志纪录，能检测双重释放（double-free）、错误释放（erroneous free）、
没有释放的内存（unfreed memory）、溢出和下溢等

-----------------------------------------------------------------------------
1. 使用printf输出信息

  可以使用条件编译指令#ifdef DEBUG和#endif把printf函数包起来。样在程序编译时
，如果加上-DDEBUG参数就能查看调试信息；否则不加该参数就不会显示调试信息。

2. gdb

前提，有源码 gcc -g
      必现的错误
      源码相对简单

使用core文件和gdb 
  段错误 -> SIGSEGV 信号 -> handle, 产生core文件

  ulimit -c 查看一下系统core文件的大小限制
  0，默认不产生core文件
  ulimit -c 1024

  gdb 程序名 core

3. objdump 

1）使用dmesg 或 串口，找到发生错误的内存地址和ip地址
2）反汇编： objdump -d 程序 > file
3）分析汇编

缺点：如果gcc 有优化参数，分析困难

4. catchsegv (捕获段错误)

它通过动态加载器（ld-linux.so）的预加载机制（PRELOAD）把一个事先写好的库（/lib/
libSegFault.so）加载上，用于捕捉断错误的出错信息。

使用： catchsegv 程序
------------------------------------------------------------------------------
**Linux环境下段错误的产生原因及调试方法小结**

1. 段错误(Segmentation Fault)

  段错误是指访问的内存超出了系统给这个程序所设定的内存空间，例如访问了不存在的
内存地址、访问了系统保护的内存地址、访问了只读的内存地址等等.

1）访问了不存在的内存地址, eg:
     int *ptr = NULL;
     *ptr = 0;

2）访问了系统保护的内存地址，eg:
     int *ptr = (int *)0;
     *ptr = 100;
3）访问了只读的内存地址，eg:
    char *ptr = "test";
    strcpy(ptr, "TEST");

4）栈溢出，eg:
    void main(void)
    {
        main();
    }

段错误信息的获取
  dmesg 或 串口

dmesg 中，搜索"segfault"可以查看发生段错误的程序名称、引起段错误发生的内存地址
、指令指针地址、堆栈指针地址、错误代码、错误原因等 


使用nm命令列出二进制文件中的符号表，包括符号地址、符号类型、符号名等，这样可以
帮助定位在哪里发生了段错误

使用ldd命令查看二进制程序的共享链接库依赖，包括库的名称、起始地址，这样可以确定
段错误到底是发生在了自己的程序中还是依赖的共享库中。



