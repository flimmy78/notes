
1. C语言是一种形式语言.

   给予形式规则赋予形式语义, 然后实现该形式规则
   与形式语义的对应, 如此则设计并实现了一门语言.


2. 信息=位+上下文.

   vim 中, 要查看文本文件的二进制编码:
    ```
    %!xxd
    ```
   要再次切换回文本形式:
   ```
   %!xxd -r
   ```


3. 语言的分类.

   按照语言所使用/遵从的编程范式分类.
   	1. 命令式的, C/C++, Java, ...
   	2. 函数式的, Lisp, Haskell, clojure...
   	3. 声明式的, prolog
   按照语言的实现方式分类.
   	1. 解释型的.
   	2. 编译型的.

4. C语言主流的实现是编译型的.

   Linux上面的编译实现主要是gcc.
   gcc的全称是 GNU Compiler Collection.
   它本身是一个编译器驱动工具.
   C语言的编译步骤: ( hello.c)
   	1. gcc -E hello.c -o hello.i
	   预处理, 调用预处理器cpp,生成.i文件
	2. gcc -S hello.c -o hello.s
	   编译, 调用编译器cc1,生成.s文件
	3. gcc -c hello.c -o hello.o
	   汇编, 调用汇编器as,生成.o文件
	4. gcc hello.c -o hello
	   链接, 调用链接器ld,生成可执行文件

	编译器cc1大概编译过程，

	 正则表达          |
		|              |
	语法、语义分析     |
		|              | ===> 前端部分，不同平台都一样。
	   DAG             |
		|			   |
	虚拟代码生成 	   |
		|
	汇编代码生成         ===>后端部分，不同硬件汇编码不同。

5. C语言有两个基本子系统
	1. 类型子系统(判定变量的类型和上下文)
	2. 表达式子系统(判定表达式优先级和结合性,求值顺序)

6. 类型子系统: 变量及其类型
	变量的定义:
	变量是命名的存储区.
	变量具有如下基本属性:
		1. 类型
		2. 地址和值
	类型:
	变量具有类型. C语言的类型分为,
		1. 基本类型. char, int, long, float, double
		2. 复合类型. 数组和指针是复合类型.
		3. 结构类型. 结构体, 共用体
	变量的类型决定如下行为:
		1. 变量的存储区域大小.
		2. 变量之上的操作.

	隐式类型转换:
		1. char 可以看成一个字节的整型
		2. unsigned int + int 结果是 unsigned int 类型
		3. 赋值(函数传递参数时)和格式化输出将产生隐式类型转换:截长补短
			截长(溢出): 直接截断高位，按赋值类型和格式化输出
			补短: 带符号按最高位补，无符号补0

	想象以表盘的形式来看待补数

7. 表达式子系统
	1. 表达式由变量, 常量, 运算符号等组成.
	2. 表达式中可含子表达式.
	3. 表达式的子表达式计算按照优先级和结合性
	   决定哪个子表达式优先计算.
	4. 表达式中的子表达式的求值顺序,
	   只有 && || , 具有求值顺序.

	优先级: 结构: () [] . ->
			单目运算符: 后缀自增减--> 取反--> 正负--> 前缀自增减--> * &
			算目运算符: 算术--> 移位--> 关系--> 位--> 逻辑
			三目运算符
			赋值
			逗号

	当表达式有两个及两个以上相同优先级的运算符，按结合性.

	自右向左结和性: 取反,正负,前缀自增减, *  &  +=类型

	关于异或的重要性质:
		a ^ b ^ a = b, b ^ a ^ a = b;

		交换两数: a = a ^ b;
				  b = a ^ b;
				  a = a ^ b;
		或 a ^= b ^= a ^= b; 不具有可移植性.


===========================> 3rd <=============================

1. 函数的声明/定义.
	声明:
	返回类型 函数名( 参数列表 )
	ret_type function_name( parameter_list );

	定义:
	ret_type function_name( parameter_list )
	{
		instructions;
	}

2. 参数列表:
	参数类型 参数名, 参数类型 参数名, ...
	type1 para1, type2 para2, ...

3. 函数调用
	function_name(argument1, argument2, ...);

4. 函数的嵌套调用:
	调用:
	f5 -> f4 -> f3 -> f2 -> f1
	返回:
	f5 <- f4 <- f3 <- f2 <- f1

5. 函数的递归调用:
	和函数的嵌套调用/返回路径一致, 只是函数
	直接或间接的调用自身.

6. 递归的分类:
	单路递归(线形递归)
	多路递归(树形递归/递归树)
	我们可以通过递归树形象的解释一切递归.

7. 变量的作用域和生存期
	作用域:
	全局变量
		声明/定义在函数体外的变量.
		全局变量的作用域从其声明/定义处开始, 到本源文件结束.
	局部变量
	局部静态变量
		声明/定义在函数体内的变量.
		局部变量的作用域从其声明/定义处开始, 到其函数结束.

	生存期:
	全局变量
		在程序的整个执行周期中一直存在.
	局部静态变量
		在程序的整个执行周期中一直存在.
	局部变量
		当函数被调用时, 局部变量被建立, 当函数调用结束后,
		局部变量被销毁.

8. 链接.
	foo.c ---cpp, cc1, as --> foo.o
				     				=====> ld ==> a.out
	main.c --cpp, cc1, as --> main.o

	在.o文件中, 存在
	.text段包含函数指令；
	.data段包含全局变量、静态变量；
    .bss段包含未初始化的全局变量、静态变量；
	.rodata段包含字符串；
	链接程序ld收集.o文件中的各个段并合并，再链接相关库， 最终生成可执行文件.

	查看汇编代码，objdump -D a.o > a.s

9. 加载.
	当执行某个可执行文件时, 如下事件发生:
	kernel建立一个进程的数据结构(task_struct)
	然后将可执行文件加载入内存.
	然后将pc(program counter)指向可执行程序入口, 将
	sp(stack pointer)指向内存某个位置, 这个位置就是
	该进程的栈起始点, 然后程序开始执行.

10. 虚拟地址空间布局(32位操作系统)

	|---------------| 0xffff ffff
	| 内核空间      |  3G - 4G
	|				|
	|---------------| 0xbfff ffff
	| 栈            | stack
	|               |
	|               |
	| 堆            | heap
	|---------------|
	|.bss 段        | .bss segment
	|.data 段       | .data segment
	|.rodata 段     |
	|.text 段       | .text segment
	|               |
	|---------------| 0x0

	运行时，每个程序都有自己的一个虚拟空间，由操作系统(kernel)
	将各个程序的虚拟地址分别映射到物理内存空间（比如:512M ）。
	注意只有有操作系统才来谈虚拟空间。

	运行时，每个函数都有自己的一个栈针。对于内层函数，在函数开始时，
	上层函数的栈针被保存，内层函数的栈针被创建，在函数结束时上一层的栈针被还原。

	未初始化的全局变量和局部静态变量放在 .bss段.
	初始化的全局变量和局部静态变量放在 .data段.

	局部变量在可执行文件中是不存在的, 局部变量由
	函数指令在程序运行期间动态分配内存空间存放,
	该动态内存空间称之为栈.
	简单的说: 局部变量在运行期存在于运行栈上.



==========================> 4th <=========================

 数组是复合类型, 定义数组需要确定如下两件事:
	1. 数组元素的类型.
	2. 数组元素个数.

 访问数组需要注意, 不要超出访问范围.
 程序决不能依赖于不确定的内存布局和未定义行为.

	srand(getpid());
	rand();

 实际上当数组类型作为函数参数时, 退化为一个指针类型,
 所以 sizeof(a)是4,因为在32位系统平台上,指针的大小是4个字节.


	char ary_ch[] = {'a', 'b', 'c', 'd', 'e'};  结尾没有'\0'
	char s[] = "abcde"; 	结尾有加'\0'

sizeof 是C语言关键字，在编译时计算，结果是数组的长度(包括'\0')
strlen 是库函数，在运行时，调用函数库后计算，结果是字符的个数(不包括'\0')


==========================> 5th <=========================

指针

	// p 是 unsigned 类型的变量.
	unsigned p = 0;
	int a = 8;

	// &a 是一个表达式, 这里 & 是取地址运算符,
	// 表达式的结果是一个指向int类型的指针类型的值.
	// 那么将指针类型的值赋值给unsigned类型的变量p
	// 时, 编译器会报警告, 所以我们可以使用一个强制
	// 类型转换让编译器闭嘴.
	p = (unsigned)&a;

	// 变量的类型决定了在变量之上的操作是否合法.
	// * 是间接访问运算符, 不能直接作用在unsigned类型
	// 的变量p之上, 所以我们将p强制转换为指针类型,
	// 然后再使用间接访问运算符.
	printf("*p = %d\n", *(int *)p);


	char *p = NULL;
	int a = 0x55667788;

	p = (char *)&a;

	printf("*(p + 1) = %#x\n", *(p + 1));  			0x77
	printf("*(p + 1) = %#x\n", *((short *)p + 1));	0x5566

	char *s = "hello word!";
	// *s = 'A'错误. 不能修改只读数据段.

const 变量

	// 不能通过pcon向其指向的内存位置赋值.
	const int *pcon = &a; // int const *pconi = &a;
	// *pconi = 16; 违法

	// 不能更改conpi的指向.
	int * const conpi = &a;


	const int *const p = &a;
	// p2 本身可更改.
	// 不能通过p2更改*p2, 也不能通过 *p2 更改 **p2.
	const int * const * p2 = &p;



==========================> 10th <=========================



1.	预处理器头文件包含:

	gcc默认搜索头文件位置
   	gcc -E prog.c -o prog.i
   	cpp prog.c > prog.i

   	默认搜索头文件路径:
   	/usr/include
   	/usr/local/include

   	当使用#include 预处理指令时,
   	后面的<>中填写相对于默认搜索目录的路径.
   	如果使用"", 则默认先搜索当前目录, 然后
   	再搜索系统目录.

   	-I选项用来指定除默认搜索目录之外的头文件
	搜索路径.

2. 预处理器定义
	简单定义:
	#define MACRO_NAME REPLACE

	定义"宏函数", 带参宏:
	#define MACRO_FUNC(arg1, arg2) REPLACE

	// #将参数变成一个字符串.
	#define func1(a) #a
	// ##连接两个参数.
	#define cat1(a, b) a##b


3. 条件编译
	#ifdef DEBUG
		...
	#else
		...
	#endif

	#ifndef XXX
		...
	#else
		...
	#endif

	注意条件编译是在编译期编译之前处理的,
	因此它和C语言的if语句有本质的差别, 它
	不在运行时进行条件判断.

	gcc选项 -D可以用来预定义一个宏,
	ex:
		gcc -DDEBUG ...
	代表预定义DEBUG宏

	可变参数宏

4. 库(用size命令查看可执行程序的大小)
	静态库(static library, archive, 后缀.a):
		打包好的.o档.
		打包:
		ar -crv libxxx.a 1.o 2.o ...
	当应用程序使用静态库时,
	静态库和应用程序链接在一起, 应用程序中会保存有
	静态库的副本.
	静态库的缺点:
		1. 占用空间
		2. 升级不便, 每次升级都要重新链接程序.

	共享库(shared object, dynamic linked library,
	后缀.so):
		gcc --shared -fPIC -o libxxx.so 1.c 2.c ...
	当应用程序使用共享库时,
	链接阶段应用程序需要查询函数是否定义, 但并不将
	共享库的副本保存在应用程序中. 当应用程序开始执
	行时, 操作系统会通过保留在应用程序中的相关信息
	加载相应的共享库.
	动态库/共享库的优点:
		1. 占用空间少(硬盘占用少, 内存空间占用少)
		2. 升级方便
	缺点:
		需要将其放入系统默认动态库搜索目录或者配置
		/etc/ld.so.conf才能使用, 软件发布具有依赖性.

5. gcc 选项:
	-I: 指定gcc除默认目录外的头文件搜索目录.
	-L: 指定gcc除默认搜索目录外的库文件搜索目录.
		gcc默认搜索/lib 和 /usr/lib下的库文件.
	-l: 指定链接哪一个库. 例如, 要链接数学库libm.so
	    那么编译时命令行上指定 -lm

6. 共享库加载
	系统默认到/lib /usr/lib下加载动态库.
	否则需要配置 /etc/ld.so.conf, 加入放置动态库的
	路径, 并执行ldconfig更新动态库路径信息.

------------------------------------------------------------------------
issue:

1. 编译时，出现 undefined reference 问题

原因：未找到函数的实现，
        1) 链接时缺失了相关目标文件（.o）
        2) 链接时缺少相关的库文件（.a/.so）
        3) 链接的库文件中又使用了另一个库文件
        4) 多个库文件链接顺序问题（根据库之间的依赖顺序）
        5) 在c++代码中链接c语言的库
        解决：添加一个extern "C"的声明，并包含c语言库相关的头文件
               extern "c"
               {
               #include "xxx.h"
               }

查看库文件中实现那些函数
objdump

