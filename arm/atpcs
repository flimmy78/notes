

ATPCS

===================

ATPCS是: Arm Thumb procedure Call Standard的缩写。意思是arm thumb子程序调用规范。

C语言函数与C函数之间进行调用是用同一个C函数调用方式进行的。如果我们要在汇编指令行中调用C函数，那么我们就要知道我们如何给C函数传递参数，哪个寄存器表示什么意思，C中的数据栈是如何使用的，我们如何获得函数的返回值。同样，如果我们用汇编代码写的汇编函数，要让C语言能调用的话，我们的汇编函数也需要按照C语言的函数编译成汇编的形式进行书写。因此，ATPCS就是这样一种规范子程序相互调用的规则。


寄存器的使用规则：

	寄存器使用规则，
				
		在ARM处理器中的每种模式下有16个基本的寄存器，从r0-r15。ATPCS规定了个个寄存器的用途和命名。

		r15, 也叫pc, 程序计数器。 始终指向下一条即将要执行的指令的地址。（相当于X86平台下面的ip寄存器。）
		r14, 也叫lr, 连接返回寄存器。当我们调用一个函数的时候，我们需要保存当前函数执行的地址，lr就是用于保存当前执行的地址的寄存器，用于执行完调用函数之后返回用。
		r13, 也叫sp, 程序栈指针寄存器。
		r12, 也叫ip, 用于临时存储
		r11, 也叫fp, 程序帧指针，

		r10到r0用于局部变量和参数传递用。	但是，如果在函数中改动了r4到r14的寄存器的值的话，需要进行先保存，后使用，最后函数退出前恢复。

	数据栈使用规则，

		ARM有4种数据栈，分别是：

			递增空栈，
			递增满栈，
			递减空栈，	
			递减满栈，

		ATPCS规定数据栈为递减满栈。
                         stmfd
                         ldmfd

	参数传递规则，

		当参数个数小于等于4个的时候，使用r0到r3这4个寄存器进行参数传递；如果参数个数大于4个，余下的参数就通过sp所指向的数据栈进行参数传递。比如有3个参数的话，那么r0代表函数的第一个参数，r1代表函数的第二个参数，r2代表函数的第三个参数。比如有6个参数的话，那么r0-r3表示前面4个参数，然后余下的两个参数通过在栈上开辟8字节的空间进行参数传递。

	函数的返回值，
		
		函数调用完毕后，如果函数有返回值，函数一般把返回值保存在r0寄存器中，因此一般我们通过bl指令调用一个函数后，就可以通过在汇编里面访问r0得到返回值。


举个例子：

A：通过汇编语言调用C语言的函数：

	比如我要通过汇编语言调用下面的add函数，下面是add函数的代码，

	int add( int a, int b , int c )
	{
		return a + b + c;
	}	

	比如我要用汇编语言作等同于add( 3, 4, 5 )；的函数调用，汇编代码如下，

	mov r0, #3
	mov r1, #4
	mov r2, #5
	bl add

B：通过C语言调用用汇编些的函数：

	下面是通过汇编实现的函数，可以通过C进行调用。

	.global add		# 申明此函数符号为全局
add:					# 函数标签名
	add r1, r1, r2	# 把C传过来的第二个参数加上第三个参数结果存入r1中。
	add r0, r0, r1	# 把第一个参数于上面的r1相加结果存在r0中，同时用做返回值。
	mov pc, lr		# 返回调用函数

	我们可以把上面代码保存为一个add.s， 然后通过arm-linux-gcc -c add.s -o add.o 生成目标代码。然后在如下的C程序中调用，


	int main( )
	{
		int result = add( 12, 34, 34 );
		printf("result = %d\n", result );
		return 0;
	}
		
	假如此C程序命名为main.c，那么联合上面的add.o编译为： gcc main.c add.o -o main。

	执行./main， 输出80


