Shell介绍

  Shell基本上分两大类

	1.图形界面shell
        windows         Explorer
		linux           GNOME / KDE等

	2.命令行式shell
		windows         command.com (MS-DOS系统)
		linux           bash / sh / ksh / csh 等

	IBM                 ksh
	FreeBSD             csh
	Linux               bash

	ls   /bin/*sh       
	cat  /etc/shells    查看当前系统支持的Shell

	交互式shell         等待用户输入命令再执行 
	非交互式shell       不与用户交互，而是读取存放在文件里的命令，并执行它们

	命令行式shell的好处
		当远程联机时，命令行界面传输速度一定比较快，不会出现断线或信息外流的
        问题，而且多接触些命令行的东西会让我们更了解Linux

	Bash Shell的功能

		命令记忆能力
		命令与文件补全功能
		命令别名设置功能
		作业管理，前台后台控制
		Shell Scripts的强大功能
		通配符
----------------------------------------------------------------------------
基本

  Bash Shell 特殊符号
		#	    注释,行首以#开头到换行符 (#!是个例外)
                注释也可以存在于本行命令的后边, 注意#前边的空白

                标准的引用和转义字符("'\)可以用来转义#
                
                echo ${PATH#*:}       参数替换,不是一个注释
                echo $(( 2#101011 ))  数制转换,不是一个注释

		;       命令分隔符,可以用来在一行中来写多个命令

        ;;      终止"case"选项

        .       作命令等价于source命令, bash内建命令 
                作目录，当前目录
                作字符匹配，这是作为正则表达是的一部分,用来匹配任何的单个字符

        ,       逗号链接了一系列的算术操作,虽然里边所有的内容都被运行了,但只有最
                后一项被返回. let "t2 = ((a = 9, 15 / 3))" 

		\	    escape, 转义
		/	    路径分割符
		~	    家目录
        :       空命令(bash的内建命令) 如 1 :
                                          2 echo $?  # 0
                                      死循环  1 while :
                                              2 do  ... done
                占位符                    

		|	    pipe, 管道
		>,>>	重定向,  >> 追加
		<,<<	重定向
		&	    作业控制 
		!	    逻辑非
		""	    soft quote
		''	    hard quote, 阻止了全部字符
		``	    命令替换
		()	    子shell起始和结束
		{}	    命令块组合
        $$      Shell本身的PID（ProcessID）
        $!      Shell最后运行的后台Process的PID
		$?	    上一条命令返回值
        $-      使用Set命令设定的Flag一览
		$0	    该bash文件名
		$*	    所有位置参数的内容，返回的是一个字符串
		$@	    所有位置参数的内容，返回多个字符串
		$#	    返回所有位置参数的个数
        $1～$n  参数值。$1是第1参数、$2是第2参数...

        "-"     减号
                  1.参数
                  2.表示上一级工作目录
                  3.代表标准输出流， tar -cvf - home/ | tar -xvf -

        shift   重新分配位置参数，把所有的位置参数都向左移动一个位置

    环境变量
        $IFS     Internal Field Separator （内部字段分隔符）

    冒号与等号大于小于
        1. 设定缺省值(:=): 
            1.1 未定义时, 生成缺省值;
            1.2 空值时, 有冒号就生成缺省值;
            1.3 有值时, 不覆盖.
        2. 缺省值(:-):  
            2.1 未定义时, 原变量str不会变; 返回值var可覆盖;
            2.2 空值时, 变量str不会变; 
            2.3 有值时, 不覆盖.
        3. 覆盖缺省值(:+): 3.1 未定义时, 原变量str, 返回值var不会变; 
            3.2 空值时, 原变量str不会变;
            3.3 有值时, 覆盖变量str的缺省值
        注意:
        1. =, -有值时, 原变量不变, 只有:+才能覆盖;
        2. +, -无值时, 原变量str仍为空.

    冒号与大于号    :>
       :>  file.txt   清空文件
       :>  $var       清空$var 所指的文件

---------------------------------------------------------------------------
变量

  Bash并不对变量区分"类型".本质上,Bash变量都是字符串

  定义赋值
    var=123
    var="string"
    foo=$var

    var=`cmd`      
    var=$(cmd)      cmd命令的结果

    let var=16+5

    for 循环中

    read命令:   echo "value" | read variable

    eval arg1 [arg2] ... [argN]
        将表达式中的参数,或者表达式列表,组合起来,并且评估它们.包含在表达式中的任何变量
        都将被扩展.结果将会被转化到命令中.

      1、eval会把赋值语句中双引号之间的内容直接赋给‘=’前的变量，而不是当作字符串赋给变量
        version="(2 4)" 是将字符串赋值给 version;
        eval version="(2 4)" 执行时变成了 version=(2 4), 是把数组 (2 4) 赋值给 version;
      
      2、当在一个赋值语句的前面加上 eval 时，它就会将后面表达式中以 $ 开头的所有变量进行整体替换
        var1="1234"
        tmp=var
        eval test="$"$tmp"1"  # 或者eval test=\$$tmp"1"，如果是eval test=$$tmp"1"会先把$$解释成进程号      
        echo   $test
        那么就会在屏幕上显示出：
                 1234

      3、最后一个参数 eval echo \$$#
         变量当命令   CMD=$*;eval $CMD

  引用
    echo $a    删除空白符 
    echo "$a"  保留空白符

  变量作用域
    1. Shell脚本中定义的变量是global的，其作用域从被定义的地方开始，到shell结束或被显示删除的地方为止
    2. Shell函数定义的变量默认是global的，其作用域从“函数被调用时执行变量定义的地方”开始，到shell结束或被显示删除处为止。函数定义的变量可以被显示定义成local的，其作用域局限于函数内。但请注意，函数的参数是local的。
    3. while read line循环里面的变量没法传出来
        不要用管道（|），因为管道会导致循环在一个子shell中运行，exit return
        都会失效
---------------------------------------------------------------------------
字符串
  字符串处理
        
---------------------------------------------------------------------------
命令如何执行

  shell命令分类1
    内部命令	实现在shell解释器内部的命令
    外部命令	文件系统中的可执行文件

  shell命令分类2
    简单命令	单一的执行某个命令
    
    管道	    通过管道组合单一命令

    命令队列	通过 && || ; & 连接执行的命令
              cmd1&&cmd2, 表示“cmd1执行成功就执行cmd2”
              cmd1||cmd2, 表示“cmd1执行失败就执行cmd2”
  
    复合命令	以shell保留字/控制运算符开始, 以shell保留字/控制运算符
              结束的shell编程结构. 
              控制运算符: 包括换行符和 || && & ; ;; | |& ( )
  
    协同进程	以保留字coproc开头执行的命令. 
              和一般命令与父进程同步执行(意即:串行)不同,
  			协同进程与父进程异步执行(意即:并行)  .请参看bash文档.
    
    嵌套执行  有两种方法``和$()引用

  命令执行流程
	1) 以IFS(Internal Field Seperator)将所输入字面量拆分为字段(word).
	2) 语法分析. 对复合命令加入控制结构和管道处理等, 分解为简单命令.
	3) 进行简单命令扩展.
	4) 搜索命令并执行.

  简单命令扩展
	1) 被解释器当作变量赋值的单词, 将被保存下来以备后续处理.
	2) 不是变量赋值会被扩展. 扩展之后, 第一个单词作为命令名称,
       其后作为该命令的选项和参数.
	3) 进行重定向处理.
	4) 每个变量赋值语句中"="后面的文本在赋给变量之前会进行大括号扩展,
       参数扩展, 命令替换, 算术扩展和引用去除.

  命令搜索
	1) 搜索shell函数.
	2) 搜索别名.
	3) 搜索内部命令.
	4) 搜索$PATH.

--------------------------------------------------------------------------------
条件判断

3.1 shell以命令退出状态为条件判断依据. 退出状态0为true, 非0为false.

3.2 条件控制结构:

	if condition; then
		cmd
	fi

	if condition
	then
		cmd
	fi

	if condition
	then
		cmd1
	else
		cmd2
	fi

	if condition1
	then
		cmd1
	elif condition2
	then
		cmd2
	...
	else
		cmd
	fi

3.3 condition:
	任意命令的退出状态.
	最常用的为 [ 或者test 命令:

	与文件存在与否的判断
		
		-e                       是否存在
		-f                       是否为普通文件
		-d                       是否为目录
		-s                       是否为空的文件
		-p                       是否为管道文件
		-b                       是否为块设备文件
		-c                       是否为字符设备文件
		-L                       是否为软链接
		-S                       是否Socket文件

	与文件权限有关的判断

		-r                       是否有可读的权限
		-w                       是否有可写的权限
		-x                       是否有可执行权限
		-u                       是否有特权位
		-g                       是否有组特权位
		-k                       是否有t位，即粘贴位

	两个文件的比较判断

		-nt                      比较file1比file2新
		-ot                      比较file1比file2旧
		-ef                      比较file1和file2是否为同一个文件，
                                 一般用于判断硬链接

	整数之间的大小判断

		-eq                      相等
		-ne                      不等于
		-gt                      大于
		-ge                      大于等于
		-lt                      小于
		-le                      小于等于

	字符串之间的判断

		-z                       是否为空字符串
		-n                       是否为非空字符串
		str1 = str2              是否相等
		str1 != str2             是否不等

	多重条件判断

		-a                       两个条件同时满足，就为真，相当于and
		-o                       两个条件满足其一，就为真，相当于or

	如果使用 [[ ]], 则多重判断可以使用:
		[[ xxx && xxx || xxx ]] 的形式.


===========================================================================

四. 算术运算

	id++  id--
	++id  --id
	- +   正负
	! ~
	**
	* / %
	+ -
	<< >>
	<= >= < >
	== !=
	&
	^
	|
	&&
	||
	cond ? expr1 : expr2
	= *= /= %= += -= <<= >>= &= ^= |=
	expr1, expr2


	let a++                     支持数学运算让a自加1
	let 'a+=3'                  数学运算a=a+3

	c=$[a+5]                    让变量a的值加5赋给c

	d=$((a+7))                  让变量a的值加上7再把结果赋给变量d

	f=`expr $a / 3`             支持运算并把结果给变量f

===========================================================================

五. 循环
        
    for 循环语句
        
        for i in 1 2 3 4 5 6            循环6次
        do
            循环体
        done

        for ((i = 0; i < 9; i++))       C语言风格，循环9次, i自加式循环
        do
            循环体
        done

        for ((i = 10; i > 0; i--))      C语言风格，循环10次，i自减式循环
        do
            循环体
        done

        for i in `seq 100`              产生1到100的序列循环
        do
            循环体
        done

        for i in `seq 10 50`            产生10到50序列循环
        do
            ...
        done

        for i in `seq 1 5 100`          产生1到100序列循环，每次以5增加
        do
            ...
        done

        for i in `ls /etc/*`            可以把一批文件，作为值循环赋值给变量
        do
            循环体
        done

        for i in ${array[@]} 
        do
            循环体
        done

----------------------------------------------------------------------

until 循环
        
   满足条件就循环结束

   使用until写出从1打印到5

       a=1
       until [ $a -gt 5 ]
       do
           echo $a
           let a++
       done

------------------------------------------------------------------
            
while 循环
        
        循环次数不确定，或者是死循环等用while循环

        while [ ]   条件为真循环
        do

        done

        死循环两种
            
            while true
            do

            done

            while :
            do 
                
            done
 
----------------------------------------------------------------------

六、常用脚本控制内部命令
        
  exit                退出脚本
  return		      退出函数
  break               退出循环
  continue            跳过此次循环
  sleep               延时
    
  随机数
    echo $RANDOM                产生随机数
    set | grep RANDOM           查看最后一次产生的随机数

  产生0到1的随机数
    echo $((RANDOM % 2))
    echo $[RANDOM % 2]
        
  产生0到100随机数
    echo $[RANDOM % 101]
  
  产生50到150的随机数
    echo $[RANDOM % 101 + 50]

  getopts   
    用途，处理命令行参数，并校验有效选项。
        （选项由一个+（加号）或者是由一个-（减号）后跟一个字符开始）
	语法，getopts 选项字符串 名称 [ 参数 ...] 
	    每次调用getopts命令时,它将下一个选项的值放置在[名称]内，并将下一个要
        处理的参数的索引置于shell变量OPTIND中。一旦调用了shell , OPTIND 将初
        始化为1。如果选项字符串中的字符后面带有“:”（冒号），则预期此选项将带
        有参数。当选项需要选项参数时，getopts 命令就将其置于变量 OPTARG 中。
	
	getopts a:bc: OPT  ：规定 a、b和c为有效选项,并且选项 a 和 c 带有参数
	getopts :a:b:c OPT ：指定 a、b和c为有效选项,并且选项 a 和 b 带有参数
                         而且getopts 在命令行遇到未定义的选项时，它将OPT的值
                         设置为?
    
  local                表示变量的作用域只在这个函数内部

  readlink -f [file]   把相对路径或者符号链接转化为绝对路径 

  tr ',' ' '           对一行进行字符串替换的程序，表示把[,]替换成[空格]
                        tr -d '\n\r' 删除换行
                        tr -s '\n' ' ' 换行变空格 

  unset ENV            清除环境变量


  read [option] [var]  接收标准输入（键盘）的输入，或其他文件描述符的输入 
                       遇到Enter结束，放到var变量中

  -r   指定读取命令把一个 \ (反斜杠) 处理为输入行的一部分，而不把它作为一个控制字符。 
  -p   提示语句
  -n   字符个数, 读到相应字符即退出. bash支持
  -t   等待时间, 若无则阻塞.
  -s   不回显
    
  缺省[var]：数据放置在环境变量REPLY中     
  cat test | while read line   读取test文件，cat 命令的输出作为read命令的
                               输入,read读到的值放在line中 

  free  使用表格形式来显示内存和缓存的使用情况. 这个命令的输出非常适合于使用 grep, awk
  或者 Perl 来分析. procinfo 命令将会显示 free 命令所能显示的所有信息, 而且更多.

--------------------------------------------------------------------------
    echo -n 不换行输出
      $echo -n "123"
      $echo "456"
      最终输出: 123456

    echo -e 处理特殊字符
      若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：
        \a 发出警告声；
        \b 删除前一个字符；
        \c 最后不加上换行符号；
        \f 换行但光标仍旧停留在原来的位置；
        \n 换行且光标移至行首；
        \r 光标移至行首，但不换行；
        \t 插入tab；
        \v 与\f相同；
        \\ 插入\字符；
        \nnn 插入nnn（八进制）所代表的ASCII字符；

        $echo -e "a\bdddd"   // dddd
        $echo -e "a\adddd"   //adddd, 输出同时会发出报警声音
        $echo -e "a\ndddd"   //自动换行
-------------------------------------------------------------------------
    cut OPTION... [FILE]...
    Print selected parts of lines from each FILE to standard output

--------------------------------------------------------------------------
    trap
    USAGE: trap [action condition ...]
    当捕捉到 condition 列表所对应的任何一个信号时，执行 action 动作
    action 可以是 shell 内建指令、外部命令及脚本中的函数等，还可是""（空）
    、’-'等，分别代表忽略相应信号及重置相应信号为默认行为。

    在trap中可以定义对信号0的处理，shell程序在其终止时（如exit）发出改信号

        condition：比如终端中断信号（一般用 CTRL-C 发出），到底是写 SIGINT 、 INT 还是2（大部分系统上该信号对应的信号数）？是大写还是小写？
        如果你使用最新版的 Bash ，那么这几种写法都可以。而如果你需要在不同 shell 中保持可移植性，请使用大写、不带前缀的 INT ！根据 POSIX 标准， trap 的 condition 不应当加上 SIG 前缀，且必须全大写，允许带 SIG 前缀或小写是某些 shell 的扩展功能。而信号数在不同的系统上可能不同，所以也不是一个好主意。

        事实上， trap 可以根据你的需要放在脚本中的任何位置。脚本中也可以有多个 trap ，可以为不同的信号定义不同的行为，或是修改、删除已定义的 trap 。更进一步地， trap 也有作用范围，你可以把它放在函数中，它将只在这个函数里起效！你看，其实 trap 的行为是很符合 UNIX 的惯例的。

        信号究竟是在什么时候被 trap 处理？
        如果当前正有一个外部命令在前台执行，那么 trap 会等待当前命令结束以后再处理信号队列中的信号。

----------------------------------------------------------------------
mktemp [OPTION]... [TEMPLATE]
Create a temporary file or directory, safely, and print its name.

[OPTION]
    　　　没有选项时建立本地临时文件
    -t　　在系统的临时目录/tmp 下建立临时文件
    -d　　建立临时目录
[TEMPLATE]
    结尾至少3个XXX

----------------------------------------------------------------------

菜单： (1)case  (2)select

      (1) case
        case "$1" in            获得变量值
            
            a)                  如果变量值等于a，执行下面echo A
                echo A
                ;;
            b)
                echo B
                ;;
            c)
                echo C
                ;;
            *)
                echo D
                exit 1
        esac
    
        例:
            敲一个键，判断是大写字母，小写字母，还是数字或其它
                
                [:alnum:]       字母数字
                [:blank:]       空格或者制表符
                [:digit:]       纯数字
                [:lower:]       小写字母
                [:upper:]       大写字母
                [:punct:]       标点符号

                read -n 1 -p "hit a key on your keyboard: " key

                case "$key" in
                    [[:lower:]])
                        echo "lowercase letter"
                        ;;
                    [[:upper:]])
                        echo "uppercase letter"
                        ;;
                    [0-9])
                        echo "number"
                        ;;
                    *)
                        echo "others"
                esac


            输入一个人名，选择性别boy girl
                
               case "$sex"  in
                    B|b)
                        echo boy
                        ;;
                    G|g)
                        echo girl
                        ;;
                    *)
                        echo "invalid select!!"

      (2) select 建立菜单的另一种工具，它是从ksh引进的
            
             PS3=""              PS3是select命令用来加入提示字符串的环境变量
                                 (默认使用的提示符为#?)

             select var in a b c d...           
             do
                代码段
             done


            例：
                PS3="Please input : "

                select os in xp vista windows7 linux unix
                do
                    echo 
                    echo "your select system is : $os"
                    echo
                    break
                done
        
----------------------------------------------------------------------

数组
    
    数组没有类型，里面的元素也是可以任意类型

    数组的定义方式一:
      a=(1 2 3 a b c "hello world")    定义a数组，只能使用数字下标去访问元素

    数组的定义方式二:
      arr[3]="hi"                      定义数组，可以不连续
      arr[0]="com"
      arr[4]="boay"

    数组的定义方式三:
      arr=([0]="he" [1]="hi" [2]=123)

    数组元素的访问
      echo ${a[0]}                     打印结果为1,访问第一个元素
      echo ${a[3]}                     访问第四个元素，打印结果为a
      echo ${a[6]}                     访问第六个元素，打印结果为hello world
   
    获取数组元素的个数
      echo ${#a[*]}
            
    输出所有元素
      echo ${a[*]}
      echo ${a[@]}

    数组的复制
      b=(${a[*]})

----------------------------------------------------------------------

函数
    
  定义方式
        
        function fun_name () {
                ...
        }

        function_name () {
                ... 
        }
        
    例

        choice () {
            PS3="Please input : "

            select os in xp vista windows7 linux unix
            do
                echo 
                echo "your select system is : $os"
                echo
                break
            done

            return 3
        }

        choice                      调用函数

        echo $?                     得到函数的返回值

----------------------------------------------------------------------

常用

    cat <<-EOF >&2   表示打印后面的内容，知道EOF（EOF需要单独在一行），
                     使用EOF的目的是实现多行文件的输出  

