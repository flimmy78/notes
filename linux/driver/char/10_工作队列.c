http://blog.sina.com.cn/s/blog_704211f40100xp0k.html

  工作队列(work queue)是Linux kernel中将工作推后执行的一种机制。
这种机制和BH或Tasklets不同之处在于工作队列是把推后的工作交由一个
内核线程去执行，因此工作队列的优势就在于它允许重新调度甚至睡眠。

include/linux/workqueue.h
Kernel/kernel/workqueue.c

struct work_struct
struct workqueue_struct

1. 工作队列的创建
要使用工作队列，需要先创建工作项，有两种方式：
  1）静态创建：
    DECLARE_WORK(name,function); 定义正常执行的工作项
    DECLARE_DELAYED_WORK(name,function); 定义延后执行的工作项
  2）动态创建，运行时创建：
    通常在probe()函数中执行下面的操作来初始化工作项：
      INIT_WORK(&work, new_ts_work);
      INIT_DELAYED_WORK(&led_work,s0340_ledtime_scanf);

工作队列待执行的函数原型是：
typedef void(*work_func_t)(struct work_struct *work);
  这个函数会由一个工作者线程执行，因此，函数会运行在进程上下文中。默认情况下，
允许响应中断，并且不持有任何锁。如果需要，函数可以睡眠。需要注意的是，尽管
该函数运行在进程上下文中，但它不能访问用户空间，因为内核线程在用户空间没有相关
的内存映射。通常在系统调用发生时，内核会代表用户空间的进程运行，此时它才能访问
用户空间，也只有在此时它才会映射用户空间的内存。

创建了工作项之后，在适当的时候可以通过下面的两种方式来提交工作项给工作者线程，
通常我们使用的工作队列和工作者线程都是系统初始化时候默认创建的。

2. 工作队列的调度运行
    schedule_work(w)；
  w 马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，它就会被执行。
    schedule_delayed_work(w,d);
  w 指向的work直到d指定的时钟节拍用完以后才会执行。

eg:
schedule_delayed_work(&kpd_backlight_work,msecs_to_jiffies(300));

3. 默认工作队列和工作者线程创建过程
  系统默认的工作队列名称是：keventd_wq, 默认的工作者线程叫：events/n，这里的
n 是处理器的编号,每个处理器对应一个线程。比如，单处理器的系统只有events/0这样一个线程。
而双处理器的系统就会多一个events/1线程。

  默认的工作者线程会从多个地方得到被推后的工作。许多内核驱动程序都把它们的下半部交给默认
的工作者线程去做。除非一个驱动程序或者子系统必须建立一个属于它自己的内核线程，否则最好使
用默认线程。不过并不存在什么东西能够阻止代码创建属于自己的工作者线程。如果你需要在工作者
线程中执行大量的处理操作，这样做或许会带来好处。处理器密集型和性能要求严格的任务会因为拥
有自己的工作者线程而获得好处。

  默认的工作队列keventd_wq只有一个，但是其工作者线程在每一个cpu上都有。而标记为singlethread
的工作者线程最存在于一个cpu上。

关于默认工作队列keventd_wq和工作者线程events/n的建立在文件kernel/kernel/workqueue.c中实现。

-------------------------------------------------------------------------------

通常，在工作队列和软中断/tasklet中作出选择非常容易。可使用以下规则：
如果推后执行的任务需要睡眠，那么只能选择工作队列；
如果推后执行的任务需要延时指定的时间再触发，那么使用工作队列，因为其可以利用timer延时；
如果推后执行的任务需要在一个tick之内处理，则使用软中断或tasklet，因为其可以抢占普通进程和内核线程；
如果推后执行的任务对延迟的时间没有任何要求，则使用工作队列，此时通常为无关紧要的任务。
实际上，工作队列的本质就是将工作交给内核线程处理，因此其可以用内核线程替换。
但是内核线程的创建和销毁对编程者的要求较高，而工作队列实现了内核线程的封装，不易出错，
所以我们也推荐使用工作队列。
